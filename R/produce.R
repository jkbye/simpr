#' Produce simulated data from specification
#'
#' Use specification from \code{\link{blueprint}} or \code{\link{meta}} to
#' produce simulated data.
#'
#' This is the third step in the simulation process: after specifying the
#' variables and metaparameters, \code{produce} is the workhorse function that
#' actually generates the simulated datasets, one for each replication, for each
#' combination of metaparameters. You likely want to use the output of
#' \code{produce} to fit model(s) with \code{\link{fit}}.
#'
#' Errors you get using this function usually have to do with how you specified
#' the simulation in  \code{\link{blueprint}} and \code{\link{meta}}.
#'
#' @param x a \code{simpr_spec} object generated by \code{\link{blueprint}} or
#'   \code{\link{meta}}, containing the specifications of the simulation
#' @param reps number of replications to run (a whole number greater than 0)
#' @seealso \code{\link{blueprint}} and \code{\link{meta}} for examples of how
#'   these functions affect the output of \code{produce}
#' @return a \code{simpr_gen} object, which is a tibble with a row for each
#'   repetition (a total of \code{rep} repetitions) for each combination of
#'   metaparameters and some extra metadata used by \code{\link{fit}}.  The
#'   columns are \code{rep} for the repetition number, the names of the
#'   metaparameters, and a list-column \code{sim_cell} containing the dataset for
#'   each repetition and metaparameter combination.
#' @examples
#' meta_list_out = blueprint(x = ~ MASS::mvrnorm(n, rep(0, 2), Sigma = S)) %>%
#'   meta(n = c(10, 20, 30),
#'        S = list(independent = diag(2), correlated = diag(2) + 2)) %>%
#'   produce(3)
#'
#'  ## View overall structure of the result
#'  meta_list_out
#'
#'  ## View an individual dataset of the resulting simulation
#'  meta_list_out$sim_cell[[1]]
#'
#'  ## Changing reps will change the number of replications and thus the number of
#'  ## rows in the output
#'  meta_list_2 = blueprint(x = ~ MASS::mvrnorm(n, rep(0, 2), Sigma = S)) %>%
#'   meta(n = c(10, 20, 30),
#'        S = list(independent = diag(2), correlated = diag(2) + 2)) %>%
#'   produce(4)
#'
#'  meta_list_2
#'
#' @export
produce = function(x, reps) {
  ## Check reps argument is a whole number > 0
  if(length(reps) > 1) {
    reps = reps[1]
    warning("reps has length > 1, using only first element")
  }
  if(reps != round(reps)) {
    reps = round(reps)
    warning("reps not a whole number, rounding to nearest whole number")
  }
  if(reps < 1) {
    stop("reps should be at least 1")
  }

  # Create data frame representing all possible values of meta parameter indices
  specs = expand.grid(c(list(rep = 1:reps), x$meta$indices), stringsAsFactors = FALSE)

  if(!is.null(x$meta$lookup)) {
    ## If there are list elements, join cells representing those list-columns
    ## into specs
    specs = purrr::reduce2(x$meta$lookup,
                           dplyr::inner_join,
                           .init = specs,
                           .y = names(x$meta$lookup)) # the "by" argument to the join
  }

  ## define variable "." to satisfy R CMD Check
  . = "Defining ."

  ## Generate all replications
  sim_results = specs %>%
    dplyr::group_by_at(.vars = c("rep", names(x$meta$indices))) %>%
    dplyr::do(sim_cell = purrr::pmap(., function(...) {
      eval_environment = rlang::as_environment(list(...), parent = parent.frame())

      df = purrr::map_dfc(x$variables, function(y) {

        eval_fun = purrr::as_mapper(y)
        environment(eval_fun) <- eval_environment

        gen = eval_fun() %>%
          unlist

        varnames = attr(y, "varnames")

        if(is.null(ncol(gen))) {
          gen_df = tibble::as_tibble(gen, .name_repair = "minimal")
          names(gen_df) = varnames
          assign(varnames, gen, envir = eval_environment)

        } else if(length(dim(gen)) > 3) {
          stop("More than 2 dimensional output in blueprint() not supported")
        } else if(ncol(gen) == 0) {
          stop("variable function returns 0 columns")
        } else if(ncol(gen) == 1) {
          names(gen) = attr(y, "varnames")
          assign(varnames, gen[[1]], envir = eval_environment)
        } else if(ncol(gen) > 1) {
          gen_df = tibble::as_tibble(gen, .name_repair = "minimal")

          # rename gen_df
          ## if multiple varnames given via formula lhs, use those
          if(length(varnames) > 1) {
            names(gen_df) = varnames
          } else {
            # Otherwise, use auto-numbering
            names(gen_df) = sprintf(paste0("%s%s%0", nchar(trunc(ncol(gen))), ".0f"),
                                    varnames,
                                    attr(x$variables, "sep"),
                                    1:ncol(gen))
            ## assign names to the eval_environmnent
          }
          purrr::iwalk(gen_df, ~ assign(.y, .x, envir = eval_environment))


        }

        gen_df
      })


      df

    })) %>% tidyr::unnest(cols = "sim_cell")

  ## Add some attributes to the tibble to track meta and variables
  attr(sim_results, "meta") = names(x$meta$indices)
  attr(sim_results, "variables") = purrr::map(x$variables, ~ attr(., "varnames")) %>% unlist

  ## Add "simpr_gen" class
  class(sim_results) = c("simpr_gen", class(sim_results))

  sim_results
}


